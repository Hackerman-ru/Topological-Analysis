% Это основная команда, с которой начинается любой \LaTeX-файл. Она отвечает за тип документа, с которым связаны основные правил оформления текста.
\documentclass{article}

% Здесь идет преамбула документа, тут пишутся команды, которые настраивают LaTeX окружение, подключаете внешние пакеты, определяете свои команды и окружения. В данном случае я это делаю в отдельных файлах, а тут подключаю эти файлы.

% Здесь я подключаю разные стилевые пакеты. Например возможности набирать особые символы или возможность компилировать русский текст. Подробное описание внутри.
\usepackage{packages}

% Здесь я определяю разные окружения, например, теоремы, определения, замечания и так далее. У этих окружений разные стили оформления, кроме того, эти окружения могут быть нумерованными или нет. Все подробно объяснено внутри.
\usepackage{environments}

% Здесь я определяю разные команды, которых нет в LaTeX, но мне нужны, например, команда \tr для обозначения следа матрицы. Или я переопределяю LaTeX команды, которые работают не так, как мне хотелось бы. Типичный пример мнимая и вещественная часть комплексного числа \Im, \Re. В оригинале они выглядят не так, как мы привыкли. Кроме того, \Im еще используется и для обозначения образа линейного отображения. Подробнее описано внутри.
\usepackage{commands}

% Потребуется для вставки картинки подписи
\usepackage{graphicx}

% Пакет для титульника проекта
\usepackage{titlepage}

% Здесь задаем параметры титульной страницы
\setUDK{192.168.1.1}
% Выбрать одно из двух
%\setToResearch
\setToProgram

\setTitle{ПО для топологического анализа данных}

% Выбрать одно из трех:
% КТ1 -- \setStageOne
% КТ2 -- \setStageTwo
% Финальная версия -- \setStageFinal
\setStageOne
%\setStageTwo
%\setStageFinal

\setGroup{225}
% Сюда можно воткнуть картинку подписи с помощью \includegraphics[scale=0.2]{<имя файла>}
% (scale подбирается индивидуально для конкретной картинки)
\setStudentSgn{}
\setStudent{С.А.Корняков}
\setStudentDate{29.01.2025}
\setAdvisor{Качан Олег Николаевич}
\setAdvisorTitle{-}
\setAdvisorAffiliation{Лаборатория ИИ Сбербанка}
\setAdvisorDate{}
\setGrade{}
% Сюда можно воткнуть картинку подписи с помощью \includegraphics[scale=0.2]{<имя файла>}
% (scale подбирается индивидуально для конкретной картинки)
\setAdvisorSgn{}
\setYear{2025}


% С этого момента начинается текст документа
\begin{document}

% Эта команда создает титульную страницу
\makeTitlePage

% Здесь будет автоматически генерироваться содержание документа
\tableofcontents
\newpage
% Данное окружение оформляет аннотацию: краткое описание текста выделенным абзацем после заголовка
\begin{abstract}
  Цель работы заключается в написании пошагового руководства по криптографии на эллиптических кривых. Реализованы объекты длинной арифметики, полей и эллиптических кривых. Изучены и имплементированы алгоритмы шифрования и дешифрования, электронной цифровой подписи, подсчёт количества точек на эллиптической кривой, быстрого умножения и деления длинных чисел. Протестированы объекты и алгоритмы по скорости, сравнивая с готовыми решениями. Написано руководство, которое параллельно с имплементацией объясняет и рассказывает, что и зачем было реализовано.

  \textit{Ключевые слова: эллиптические кривые, шифрование и дешифрование, криптография, ECDSA, ECC, длинная арифметика, FFT, C++, конечные поля, оптимизация, Scoof's algorithm}
\end{abstract}
\section{Введение}
Современная криптография с нынешними вычислительными мощностями требует значительных ухищрений в шифровке сообщений, и шифрование с помощью эллиптических кривых - один из мощнейших инструментов. Но доступных и полных объяснений от начала до конца по шифрованию на них ничтожно мало, поэтому я решил сделать руководство для людей, которые хотят ознакомиться с данным видом криптографии.

Задача проекта заключается в написании руководства по имплементации данного вида криптографии на личном компьютере, сведя количество используемых сторонних библиотек к минимуму, чтобы лучше понять каждый аспект работы шифрования и дешифрования.

В поставленные задачи входило:
\subsection*{Изучение теории}
Изучена теория, стоящая за эллиптическими кривыми, виды шифрований и цифровых подписей на эллиптических кривых, быстрое преобразование Фурье, алгоритмы подсчёта точек на эллиптической кривой. 

\subsection*{Реализация необходимых объектов}
Имплементированы на языке программирования C++ различные объекты для постройки нужного окружения для шифрования:
\begin{enumerate}
  \item Длинные целые числа и арифметика на них
  \begin{enumerate}
    \item Наивная реализация
    \item Применение алгоритмов из \cite{knuth2014art} 
    \item Использование FFT и других алгоритмов из \cite{knuth2014artfmd} для деления и умножения 
  \end{enumerate}
  \item Поля и арифметика на их элементах
  \item Эллиптические кривые, точки на эллиптических кривых в 6 разных видах координат, арифметика на точках \cite{das2004guide}
\end{enumerate}

\subsection*{Имплементация алгоритмов}
Написаны алгоритмы на полученных объектах:
\begin{enumerate}
  \item Вычисление количества точек на эллиптической кривой \cite{kamarulhaili2012elliptic}
  \item Алгоритмы шифрования и дешифровки сообщений \cite{das2004guideprotocols}
  \item Алгоритм построения и проверки цифровой подписи \cite{das2004guideprotocols}
\end{enumerate}

\subsection*{Оптимизация написанного кода}
Рассмотрены оптимизации, которые следуют из
\begin{enumerate}
  \item Разных видов координат точек на эллиптических кривых\cite{vasilenko2008newcoord}
  \item Специализации имплементации объектов за счёт одного вида эллиптической кривой или поля\cite{adalier2015efficient}
  \item Предположений о входных данных алгоритмов\cite{das2004guideprotocols}
\end{enumerate}

\subsection*{Тестирование библиотеки}
Проведены стресс-тесты и тесты на корректность, измерено время работы без оптимизаций, с оптимизациями и на разных видах координат точки на эллиптической кривой, сделать выводы о лучшей компоновке и реализации. Для тестирования использовалось готовое решение по тестированию проектов \cite{googletest}.

\subsection*{Изложение результатов}
В отчёте изложена теория, необходимая для понимания рассматриваемых алгоритмов, а также архитектура и дизайн написанной библиотеки.

\subsection*{Написание руководства}
Написано сопроводительное \href{https://github.com/Hackerman-ru/Elliptic-Curve-Tutorial}{руководство} к реализованным объектам и алгоритмам, которое пошагово объясняет основную теорию для шифрования, зачем и почему создавать объекты и методы, какие способы оптимизации существуют.

\section{Требования к проекту}
\subsection{Функциональные требования}
Написанная в руководстве библиотека на C++ предоставляет доступ к объектам, нужным для шифрования, и готовым алгоритмам шифрования, дешифрования, цифровой подписи. Она обладает следующими объектами и методами:
\subsubsection{Длинная арифметика}
   Для того чтобы работать с беззнаковыми числами, которые не помещаются во встроенные целочисленные типы, создан шаблонный класс беззнаковых длинных чисел с фиксированным количеством бит. У него есть все операции, которые можно делать с встроенными беззнаковыми числами и поведение аналогично им же. Есть способы конвертации из строки и обратно для удобной работы с большими числами.

   Пример использования:
    \begin{frame}

\lstset{language=C++,
                keywordstyle=\color{blue},
                stringstyle=\color{red},
                commentstyle=\color{green},
                morecomment=[l][\color{magenta}]{\#}
}
\begin{lstlisting}
    #include "uint.h"

    using ECG::uint_t;

    int main(void) {
        uint_t<512> a = "0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF";
        uint_t<512> b = 1;

        uint_t<512> result = a + b;
        std::string str = result.convert_to<std::string>();
        assert(str == "0x10000000000000000000000000000000000000");

        result = a ^ b;
        std::string str = result.convert_to<std::string>();
        assert(str == "0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE");

        result = a * b;
        std::string str = result.convert_to<std::string>();
        assert(str == "0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF");

        result = "0b1";
        size_t value = result.convert_to<size_t>();
        assert(value == 1);
    }
\end{lstlisting}
\end{frame}
\subsubsection{Конечное Поле}
   Для работы в конечных полях реализованы классы простого поля и элемента простого поля. Поле конструируется от одного параметра - простого числа в беззнаковом числе длинной арифметики. Он умеет создавать элементы поля по беззнаковому числу, а также может предоставить свой порядок.

   Класс элемента простого поля, который представляет элемент простого поля. Его нельзя сконструировать без поля. У него есть все операции, которые можно делать с элементами поля, а также возвращение значения элемента.

    Пример использования:
    \begin{frame}

\lstset{language=C++,
                keywordstyle=\color{blue},
                stringstyle=\color{red},
                commentstyle=\color{green},
                morecomment=[l][\color{magenta}]{\#}
}
\begin{lstlisting}
    #include "field.h"

    using namespace ECG; 

    int main(void) {
        uint p = "1000000007";
        Field F(p);
        FieldElement a = F(10);
        FieldElement b = F(uint("105"));

        FieldElement result = a - b;
        std::string str = result.value().convert_to<std::string>();
        assert(str == "999999912");

        result = b.inverse();
        std::string str = result.value().convert_to<std::string>();
        assert(str == "209523811");
    }
\end{lstlisting}
\end{frame}
\subsubsection{Эллиптическая кривая}
  Для работы с точками на эллиптических кривых реализованы классы эллиптической кривой и точек на ней в разных видах координат. Эллиптическая кривая конструируется от трёх параметров: коэффициентов a и b в нормальной форме Вейерштрасса уравнения эллиптической кривой и простого поля, над которым построена эллиптическая кривая и в котором лежат элементы a и b. Объект данного класса умеет конструировать точки по координате x, автоматически проверяя, лежит ли на данной кривой точка с такой координатой, а также по координатам x и y, аналогично проверяя принадлежность к кривой. Есть метод для подсчёта количества точек на эллиптической кривой, а также метод генерации случайной точки на кривой.

  Шаблонный по виду координат класс точки на эллиптической кривой. Его нельзя сконструировать без эллиптической кривой. Всего имплементированы 6 видов координат:
    \begin{itemize}
      \item Нормальные координаты
      \item Проективные координаты
      \item Координаты Якоби
      \item Модифицированные координаты Якоби
      \item Координаты Якоби-Чудновского
      \item Упрощённые координаты Якоби-Чудновского
    \end{itemize}
  У него есть все операции, которые можно делать с точками на эллиптической кривой, проверка на то, что это точка $\mathcal{O}$, а также операция умножения на беззнаковое число (т.е. сложение с собой столько раз)

  Пример использования:
  \begin{frame}

\lstset{language=C++,
                keywordstyle=\color{blue},
                stringstyle=\color{red},
                commentstyle=\color{green},
                morecomment=[l][\color{magenta}]{\#}
}
\begin{lstlisting}
    #include "EllipticCurve/elliptic-curve.h"

    using namespace ECG; 

    int main(void) {
        Field F("1000000007");
        FieldElement a = 
        F(uint("0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc"));
        FieldElement b=
        F(uint("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b"));

        EllipticCurve E(a, b, F);
        EllipticCurvePoint<CoordinatesType::Jacobi> p1 = 
        E.point_with_x_equal_to<CoordinatesType::Jacobi>(uint("9124719249999124")).value();
        std::optional<EllipticCurvePoint<CoordinatesType::Jacobi>> p2_ = 
        E.point_with_x_equal_to<CoordinatesType::Jacobi>(uint("129641236"));

        EllipticCurvePoint<CoordinatesType::Jacobi> p2 = p2_.value();

        EllipticCuverPoint<CoordinatesType::Jacobi> result =
                                  (p1 + p2) * uint("9912371247");
        uint number_of_points = EC.points_number();
    }
\end{lstlisting}
\end{frame}
\subsubsection{Шифрование}
  Для того чтобы шифровать сообщения и подписывать их, реализованы следующие классы:
\begin{enumerate}
  \item Класс шифрования Эль-Гамаля с помощью эллиптический кривых. Конструируется от эллиптической кривой, точки на этой кривой (возможно, её порядка) и функций отображения сообщения на эллиптическую кривую и обратно. Имеет методы: шифрования от сообщения и секретного ключа в пару точек на эллиптической кривой, дешифровки сообщения от пары точек и секретного ключа.
  \item Класс электронной цифровой подписи ECDSA. Конструируется от основных параметров для шифрования на эллиптической кривой. Также поддерживает создание от порядка поля и уровня безопасности. Имеет методы: генерации ключевой пары, генерации цифровой подписи от сообщения, проверки цифровой подписи по  сообщению и подписи.
\end{enumerate}
\subsection{Нефункциональные требования}
\subsubsection{Описание программы и используемых библиотек}
\begin{enumerate}
  \item Программа написана на языке C++, используется версия языка C++20.
  \item Для открытия, сборки и тестирования проекта используется Microsoft Visual Studio 2022.
  \item Программа компилируется с помощью MSVC.
  \item Используется пакетный менеджер Nuget, интегрированный в Microsoft Visual Studio 2022.
  \item Проект использует систему поддержки версий git вместе с github.
  \item Нет требований к используемой RAM или HDD.
  \item Для форматирования используется clang format.
  \item Используется clang-tidy для унификации именований и статической диагностики программы.
\end{enumerate}
\subsubsection{Используемые библиотеки}
\begin{enumerate}
  \item Библиотека \cite{boostmultiprecision} в качестве примера корректной и быстрой длинной арифметики для тестирования.
  \item Библиотека \cite{random} для криптографически-безопасной генерации случайных чисел.
  \item Библиотека \cite{hash} для хеширования с помощью SHA3.
  \item В качестве фреймворка для тестирования программы используется интегрированный в Microsoft Visual Studio 2022 Nuget пакет \cite{googletestnuget}.
\end{enumerate}
\subsubsection{Политика обработки ошибок}
\begin{enumerate}
  \item Обработка std::exception отключена в угоду оптимизации выполнения программы.
  \item Неправильный вид чисел в C-style строках при конструировании uint не обрабатывается и является UB.   \item Если пользователь складывает элементы из разных полей или точки с разных эллиптических кривых, то это никак не обрабатывается и является UB.
  \item Вставлены assertы в DEBUG версии программы для выявления ошибок имплементации методов и алгоритмов.
  \item Используется std::optional для обработки несуществования выходных данных алгоритмов и методов.
\end{enumerate}
Подытоживая, программа предполагает, что использующий её пользователь вводит верные данные и следует ограничениям используемых алгоритмов.
\section{Теория и описание алгоритмов}
    Для ознакомления с основными понятиями см. $\ref{glossary}$. 

    Опишем алгоритмы по порядку:
  \subsection{Алгоритмы длинной арифметики}
    Длинная арифметика основана на системе счисления с основанием $2^{32}$ или $2^{64}$. Для сложение и вычитания, и битовых сдвигов алгоритмы тривиальны. Рассмотрим умножение и деление:
  \subsubsection{Быстрое преобразование Фурье}
  Для того чтобы реализовать быстрое умножение и деление длинных чисел, которые представлены в виде массива целых чисел, используются алгоритмы FFT и iFFT с некоторыми поправками на то, что перемножаются числа с основанием, а не полиномы. Для начала опишем их:

  Главная задача - перемножить два полинома. Пусть $A,B\in P_d[x]$ и $C(x):=A(x)\cdot B(x)$ . Сначала сделаем такое наблюдение:
  \begin{lemma}
    $\forall A\in P_{d}[x]$ однозначно определяется $d+1$ точкой, где точка - это пара координат в $\C$.
  \end{lemma}

  Таким образом, любой полином $P(x)=p_dx^d+p_{d-1}x^{d-1}+\dots+p_1x+p_0$ представим в двух видах:
  \begin{enumerate}
    \item В коэффициентном: $[p_0,p_1,\dots,_d]$
    \item В виде точек: $(x_0, P(x_0), (x_2,P(x_2),\dots , (x_{d+1},P(x_{d+1}))))$, назовём такое представление "в значениях"
  \end{enumerate}

  Пусть мы представили $A$ в виде $((a_0,b_0),\dots,(a_d,b_d))$, а $B$ в виде $((a_0,c_0),\dots,(a_d,b_d))$. Тогда, перемножив эти вектора покомпонентно, получим представление в значениях для $C(x)$ по однозначности представления: $((a_0,b_0\cdot c_0),\dots,(a_d,b_d\cdot c_0))$ - перемножили два полинома за линейное время: $O(d)$.

  Получается, чтобы умножить два полинома степени $d$, надо перевести их в представление в значениях, перемножить покомпонентно точки и перевести обратно в коэффициентное представление. Эти переводы между представлениями и являются FFT и iFFT соответственно.
  \paragraph{FFT:}
  Заметим такой факт: если $f(x)=x^2$, то чтобы вычислить $f(x)$ в 8 точках, достаточно вычислить $f(x)$ в 4 положительных точках - тогда значения в отрицательных будут такими же. Аналогично, если $f(x)=x^2$, то чтобы вычислить $f(x)$ в 8 точках, достаточно вычислить $f(x)$ в 4 положительных точках - тогда значения в отрицательных будут противоположными.

  Учитывая предыдущий факт, разделим наш полином $A(x)$ на мономы чётных степеней и нечётных степеней, например:
  \[A(x)=1+3x-5x^2+7x^3+x^4-x^5-10x^6 =(1 - 5x^2 + x^4 - 10x^6) + (3x + 7x^3 - x^5)\]
  \[= (1 - 5x^2 + x^4 - 10x^6) + x(3 + 7x^2 - x^4)=: P_e(x^2) + xP_o(x^2)\]
  где $P_e(x)=1-5x+x^2-10x^3,\q P_o(x)=3+7x-x^2$, т.е. их степень в два раза меньше.

  Хотим вычислить $A(x) := p_{d-1}x^{d-1}+p_{d-1}x^{d-1}+\dots+p_1x+p_0$ в точках $\pm x_1,\pm x_2,\dots, \pm x_{d/2}$. Заметим, что
  \[\begin{cases}
    P(x_i) = P_e(x_i^2) + x_iP_o(x_i^2)\\
    P(-x_i) = P_e(x_i^2) - x_iP_o(x_i^2)\\
  \end{cases}\]
  Значит $P_e$ и $P_o$ надо вычислить только в $x_1^2,\dots,x_{d/2}^2$. Заметим, что сложность уменьшилась: надо вычислить полиномы меньшего размера в $d/2$ точка, т.е. всего в $d$ точках. Теоретическая сложность рекурсивного вычисления $O(n\log(n))$ против наивного перемножения за $O(n^2)$, но есть проблема - точки не противоположны друг другу, поэтому ту же идею нельзя повторять.

  Решение проблемы - использовать $\sqrt[d]{1}\in\C$. Стандартным алгоритм использует $d:=2^n$, т.е. степень двойки, хотя есть вариации, которые обходят это ограничения, но они намного сложнее, поэтому ограничимся степенью 2. Все эти $d$ точек образуют правильный многоугольник с углом поворота между вершинами $\frac{2\pi}{d}$. Тогда первый, отличный от 0, корень из $1$ будет равен $w := 1 \cdot e^{i\cdot \frac{2\pi}{d}}=e^{\frac{2\pi i}{d}}$. Тогда искомые корни: $1,w^1,w^2,\dots,w^{d-1}$, т.к. $w^{j + d/2} = -w^{j}$.

  Заметим, что при возведении в квадрат мы получим $\sqrt[d/2]{1}$, где $\frac{d}{2} = 2^{n-1}$, т.е. аналогичную ситуацию.



  Итого: Дан $P(x):(p_0,p_1,\dots,p_{n-1})$.
  \begin{enumerate}
    \item Вычислим $w:=e^{\frac{2\pi i}{n}}$
    \item Теперь нужно вычислить $P(x)$ в $w^0,w^1,\dots,w^{n-1}$: 
    \item Если $n=1$, то возвращаем $(1, P(1))$ иначе: 
    \item Разделим $P(x)$ на $P_e(x):(p_0,p_2,\dots,p_{n-2})$ и $P_o(x):(p_1,p_3,\dots,p_{n-1})$\\ и вычислим их в точках $(w^0,w^2,\dots,w^{2n-2}=w^{n-2})$, т.е. переходим к шагу 2 рекурсивно
    \item Получили представления $P_e$ и $P_o$ в значениях: 
    \[y_e = (P_e(w^0),P_e(w^2),\dots,P_e(w^{n-2})),\q y_o=(P_o(w^0),P_o(w^2),\dots,P_o(w^{n-2}))\]
    \item Вычислим представление в значениях для исходного полинома $P(x)$:
    \[
    \begin{cases}
      P(w^j) = P_e(w^{2j}) + w^jP_o(w^{2j})\\
      P(-w^j = w^{j+(n/2)}) = P_e(w^{2j}) - w^jP_o(w^{2j})\\
    \end{cases},\q j\in \left\{0,1,\dots,\frac{n}{2}-1\right\}\]
    Т.е. в терминах массивов:
    \[\begin{cases}
      P(w^j) = y_e[j] + w^jy_o[j]\\
      P(w^{j+(n/2)}) = y_e[j] - w^jy_o[j]\\
    \end{cases},\q j\in \left\{0,1,\dots,\frac{n}{2}-1\right\}\]
    \item Возвращаем $y = (P(w^0),P(w^1),\dots, P(w^{n-1}))$
  \end{enumerate}

  Псевдокод:

    \begin{algorithm}[H]
        \caption{FFT}
        \KwData{$P:[p_0,p_1,\dots,p_{n-1}],\q n = 2^d$}
        \KwResult{$y = [P(x_0), P(x_1),\dots, P(x_{n-1})]$}
        $w\gets e^{\frac{2\pi i}{n}}$

        \If{$n == 1$} {
          $y\gets P(1)$

          \Return y
        }

        $P_e\gets [p_0,p_2,\dots,p_{n-2}]$

        $P_o\gets [p_1,p_3,\dots,p_{n-1}]$

        $y_e\gets {\rm FFT}(P_e)$

        $y_o\gets {\rm FFT}(P_o)$

        \For{j = 0; j < $\frac{n}{2}$; ++j} {
          $y[j]\gets y_e[j] + w^jy_o[j]$

          $y[j + n/2]\gets y_e[j] - w^jy_o[j]$
        }

        \Return y
    \end{algorithm}

  \paragraph{iFFT:}
  Представим значения в точках в виде матриц:
  \[
  \begin{bmatrix}
  P(x_0)\\
  P(x_1)\\
  P(x_2)\\
  \vdots\\
  P_{x_{n-1}}\\
  \end{bmatrix}
  = 
  \begin{bmatrix}
  1&x_0&x_0^2&\hdots&x_0^{n-1}\\
  1&x_1&x_1^2&\hdots&x_1^{n-1}\\
  1&x_2&x_2^2&\hdots&x_2^{n-1}\\
  \vdots&\vdots&\vdots&\ddots&\vdots\\
  1&x_{n-1}&x_{n-1}^2&\hdots&x_{n-1}^{n-1}\\
  \end{bmatrix}
  \begin{bmatrix}
  p_0\\
  p_1\\
  p_2\\
  \vdots\\
  p_{n-1}\\
  \end{bmatrix}
  \]
  В FFT мы использовали $x_k=w^k$, где $w:=e^{\frac{2\pi i}{n}}$. Тогда матрица имеет вид:
  \[
  \begin{bmatrix}
  P(x_0)\\
  P(x_1)\\
  P(x_2)\\
  \vdots\\
  P_{x_{n-1}}\\
  \end{bmatrix}
  = 
  \begin{bmatrix}
  1&1&1&\hdots&1\\
  1&w&w^2&\hdots&w^{n-1}\\
  1&w^2&w^4&\hdots&w^{2(n-1)}\\
  \vdots&\vdots&\vdots&\ddots&\vdots\\
  1&w^{n-1}&w^{2(n-1)}&\hdots&w^{(n-1)(n-1)}\\
  \end{bmatrix}
  \begin{bmatrix}
  p_0\\
  p_1\\
  p_2\\
  \vdots\\
  p_{n-1}\\
  \end{bmatrix}
  \]
  Матрица посередине называется матрицей DFT. Тогда для интерполяции (выведения коэффициетов через значения) нужно обратить данную матрицу:
  \[
  \begin{bmatrix}
  p_0\\
  p_1\\
  p_2\\
  \vdots\\
  p_{n-1}\\
  \end{bmatrix}
  = 
  \begin{bmatrix}
  1&1&1&\hdots&1\\
  1&w&w^2&\hdots&w^{n-1}\\
  1&w^2&w^4&\hdots&w^{2(n-1)}\\
  \vdots&\vdots&\vdots&\ddots&\vdots\\
  1&w^{n-1}&w^{2(n-1)}&\hdots&w^{(n-1)(n-1)}\\
  \end{bmatrix}^{-1}
  \begin{bmatrix}
  P(x_0)\\
  P(x_1)\\
  P(x_2)\\
  \vdots\\
  P_{x_{n-1}}\\
  \end{bmatrix}\]
  \begin{lemma}
    \[\begin{bmatrix}
  1&1&1&\hdots&1\\
  1&w&w^2&\hdots&w^{n-1}\\
  1&w^2&w^4&\hdots&w^{2(n-1)}\\
  \vdots&\vdots&\vdots&\ddots&\vdots\\
  1&w^{n-1}&w^{2(n-1)}&\hdots&w^{(n-1)(n-1)}\\
    \end{bmatrix}^{-1}
    =
    \frac{1}{n}
    \begin{bmatrix}
  1&1&1&\hdots&1\\
  1&w^{-1}&w^{-2}&\hdots&w^{-(n-1)}\\
  1&w^{-2}&w^{-4}&\hdots&w^{-2(n-1)}\\
  \vdots&\vdots&\vdots&\ddots&\vdots\\
  1&w^{-(n-1)}&w^{-2(n-1)}&\hdots&w^{-(n-1)(n-1)}\\
  \end{bmatrix}\]
  \end{lemma}

  Таким образом, чтобы интерполировать результаты перемножения двух полиномов, достаточно применить FFT с $w= \frac{1}{n}e^{-\frac{2\pi i}{n}}$.

  Псевдокод:

    \begin{algorithm}[H]
        \caption{iFFT}
        \KwData{$P:[p_0,p_1,\dots,p_{n-1}],\q n = 2^d$}
        \KwResult{$y = [P(x_0), P(x_1),\dots, P(x_{n-1})]$}
        $w\gets \frac{1}{n}e^{-\frac{2\pi i}{n}}$

        \If{$n == 1$} {
          $y\gets P(1)$

          \Return y
        }

        $P_e\gets [p_0,p_2,\dots,p_{n-2}]$

        $P_o\gets [p_1,p_3,\dots,p_{n-1}]$

        $y_e\gets {\rm FFT}(P_e)$

        $y_o\gets {\rm FFT}(P_o)$

        \For{j = 0; j < $\frac{n}{2}$; ++j } {
          $y[j]\gets y_e[j] + w^jy_o[j]$

          $y[j + n/2]\gets y_e[j] - w^jy_o[j]$
        }

        \Return y
      \end{algorithm}

  Алгоритм умножения двух длинных чисел в имплементации подвергся некоторым изменениям в угоду оптимизации и ускорения вычисления. Объяснения оптимизаций и код к ним можно найти в репозитории проекта.
  \subsubsection{Деление длинных чисел}
   Рассмотрим алгоритм $D$ деления длинных чисел, описанный Кнутом в \cite{knuth2014art}:

   Задача - поделить два длинных числа, представленных цифрами с основанием $b$, где $b$ в имплементации $2^{32}$ или $2^{64}$. 

   Рассмотрим сначала $u=(u_nu_{n-1}\dots,u_0)_b$ и $v=(v_{n-1}\dots v_0)_b$, где $u/v <b$. Найдём алгоритм для вычисления $q:=\lfloor u/v \rfloor$:

   Заметим, что $u/v<b\Leftrightarrow u/b < v\Leftrightarrow \lfloor u/b\rfloor < v$, а это условие того, что \[(u_nu_{n-1}\dots,u_1)_b <  (v_{n-1}\dots v_0)_b\]
   Если обозначить $r:=u - qv$, то $q$ - это уникальное число, такое что $0\leqslant r <v$. Пусть
   \[\hat{q}:=\min \left(\left\lfloor \frac{u_nb + u_{n-1}}{v_{n-1}}\right\rfloor, b-1\right)\]
   Т.е. мы получаем гипотетическое значение $q$, поделив первые две цифры $u$ на первую цифру $v$, а если результат деления больше или равен $b$, то берём $b-1$. Для такого $\hat{q}$ выполняются две теоремы: 
   \begin{theorem}
    $\hat{q}\geqslant q$
   \end{theorem}
   \begin{theorem}
     Если $v_{n-1}\geqslant \lfloor b/2\rfloor$, то $\hat{q}-2\leqslant q\leqslant \hat{q}$.
   \end{theorem}
   Существенно ограничили нашу гипотезу. Умножив $u$ и $v$ на $\lfloor b/(v_{n-1}+1)\rfloor$, мы не изменим длину числа $v$ и результат деления. После этого умножения станет выполнятся вторая из данных теорем.

   \paragraph{Алгоритм $D$:} Дано неотрицательное целое число $u = (u_{m+n-1},\dots,u_1,u_0)_b$ и $v = (v_{n-1},\dots,v_1,v_0)_b$, где $v_{n-1}\neq 0$ и $n>1$. Мы хотим посчитать $\lfloor u/v\rfloor = (q_m,q_{m-1},\dots,q_0)_b$ и остаток $u$ mod $v$ $= (r_{n-1},\dots,r_0)_b$:

   \begin{enumerate}
     \item $d:=\lfloor b/(v_{n-1}+1)\rfloor$. Тогда пусть $(u_{m+n}u_{m+n-1}\dots u_1u_0)_b:=(u_{m+n-1}\dots u_1u_0)_b\cdot d$, аналогично, $(v_{n-1},\dots,v_1,v_0)_b =(v_{n-1},\dots,v_1,v_0)_b\cdot d$. Заметим, что новая цифра могла появиться только у $u$
     \item Итерироваться будем по $j$, которая в начале равна $m$ (Делить в следующих шагах будем $(u_{j+n}\dots u_{j+1}u_j)_b$ на $(v_{n-1}\dots v_1v_0)_b$ чтобы получить цифру $q_j$) 
     \item $\hat{q} := \left\lfloor \frac{u_{j+n}b + u_{j+n-1}}{v_{n-1}}\right\rfloor$ и пусть $\hat{r}$ будет остатком, т.е. $\hat{r} :=u_{j+n}b + u_{j+n-1}$ (mod $v_{n-1}$)
     \item Если $\hat{q}\geqslant b$ или $\hat{q}v_{n-2}>b\hat{r} + u_{j+n-2}$, то уменьшаем $\hat{q}$ на 1 и увеличиваем $\hat{r}$ на $v_{n-1}$. Если $\hat{r}<b$, то повторяем данный шаг
     \item Заменим $(u_{j+n}\dots u_{j+1}u_j)_b$ на
     \[(u_{j+n}\dots u_{j+1}u_j)_b - \hat{q}(0v_{n-1}\dots v_1v_0)_b\]
     \item Назначаем $q_j = \hat{q}$
     \item Если число $u$ на 5 шаге получилось отрицательным, то добавляем к нему $b^{n+1}$ и переходим к шагу 8, иначе переходим к шагу 9.
     \item (Вероятность данного шага крайне мала, за счёт чего достигается асимптотическая быстрота алгоритма) Уменьшаем $q_j$ на 1 и добавляем $(0v_{n-1}\dots v_1v_0)_b$ к $(u_{j+n}\dots u_{j+1}u_j)_b$ (при сложении появится цифра $u_{j+n+1}$, её следует проигнорировать)
     \item Уменьшаем $j$ на 1. Если $j\geqslant 0$, то возвращаемся на шаг 3
     \item Теперь $q=(q_m\dots q_1q_0)$ - это искомое частное, а искомый остаток можно получить, поделив $(u_{n-1}\dots u_1u_0)$ на $d$ наивным способом 
     \item Возвращаем $(q,r)$
   \end{enumerate}
  \subsection{Алгоритмы поля}
    Так как мы используем только простые поля, то имплементируем кольцо вычетов по модулю простого числа, т.е. просто остатки от деления на простое число, - оно и будет искомым полем.

    Умножение в поле - умножение в длинной арифметике + взятие остатка. Деление - умножение на обратное к второму числу. 

    Инверсия - расширенный алгоритм Евклида:
      вычисляем НОД последовательным делением с остатком, где полученные частные и остатки помогают вычислить по формуле ещё две последовательности по рекуррентным формулам, которые в конце дадут нужное число - обратные к исходному числу по модулю простого числа. 

    Быстрое возведение в степень - стандартное: если степень n нечётная, то вычисляем степень n-1 и умножаем на исходное число, иначе вычисляем степень n / 2 и перемножаем полученное значение с собой же. На выходе получаем число в n степени, на вычисление которого ушло $O(\log_2 n)$.

    Если использовать простые числа NIST, то можно сделать некоторые оптимизации, которые недоступны в общем решении. Эти оптимизации рассмотрены в руководстве.
  \subsection{Алгоритмы Эллиптической кривой}
    В качестве эллиптической кривой рассматривается группа $G:=\{(x,y)\in \F_p | y^2=x^3+ax+b\colon 4a^3+27b^2\neq 0\}\cup \{\infty\}$, где $a,b\in\F_p$. Обозначим её $\mathbb{E}(\mathbb{F}_p)$. Точку бесконечности обозначим как $\mathcal{O}$. Опишем основные алгоритмы для нормальных координат, т.к. алгоритмы для остальных координат - это те же самые алгоритмы, только в некоторых моментах нужная информация уже предподсчитана в координатах точки для ускорения вычисления.
    \subsubsection{Сложение}
    Чтобы сложить две различные точки, надо провести через них прямую на плоскости и посмотреть, какую точку на эллиптической кривой она пересекла. Тогда симметричная ей точка, относительно оси $Ox$ и будет результатом сложения. Если прямая не пересекла никакую точку на кривой, то считаем, что сумма равна точке $\infty$. Чтобы сложить точку с собой, надо провести касательную через неё и повторить алгоритм выше. Точка $\infty$ будет нулём в данной группе. 

    Заметим, что при таком задании операции '+' обратная точка в группе - это точка с противоположной координатой $y$. С помощью уравнений выразим операцию сложения в нормальных координатах: $A,B,C\in \E(\F_p),\q A=(x_1,y_1),\q B=(x_2,y_2), \q C=(x_3,y_3)$ и $A + B = C$, рассмотрим 3 случая: 
    \begin{enumerate}
      \item $x_1\neq x_2$. Обозначим $k := \frac{y_1-y_2}{x_1-x_2}$. Пусть $C:=A+B$ и $C=(x_3,y_3)$. Тогда
      \[x_3 = k^2 - x_1 - x_2\]
      \[y_3 = k(x_1 - x_3) - y_1\]
      \item $x_1 = x_2,\q y_1 = -y_2$. Тогда $A+B = \infty$.
      \item $A = B$. Обозначим $k := \frac{3x_1^2 + a}{2y_1}$. Тогда
      \[x_3 = k^2 - 2x_1\]
      \[y_3 = k(x_1 - x_3) - y_1\]
    \end{enumerate}
    \subsubsection{Умножение}
    Умножение на число n - это сложение n раз точки с собой. Есть несколько этапов:
    \begin{enumerate}
      \item Представить число n в \textit{non-adjancent form}(NAF) форме - это уникальное представление числа в двоичном основании, где есть цифра $-1$. Такое представление помогает достичть минимального веса Хэмминга (количество цифр, отличных от 0), что заметно ускорит умножение точки на число, если удвоение точки будет быстрее сложения. Алгоритм перевода из двоичной системы исчисления в NAF: 

       \begin{algorithm}[H]
        \caption{NAF from binary}
        \KwData{$n=(n_{m-1}n_{m-2}\dots n_0)_2$}
        \KwResult{$z = (z_{m}z_{m-1}\dots z_1z_0)_{NAF}$}
        $i\gets 0$

        \While{$n > 0$} {
          \eIf{$n$ \rm is odd } {
            $z_i\gets 2 - (n\mod 4)$
            $n\gets n - z_i$
          } {
            $z_i\gets 0$
          }
          $n\gets n/2$

          $i\gets i+1$
        }
      \end{algorithm}
       Есть версия данного алгоритма, которая основана на битовых операциях:

      \begin{algorithm}[H]
        \caption{NAF from binary by bit operations}
        \KwData{$x=(x_{m-1}x_{m-2}\dots n_0)_2$}
        \KwResult{$z = (z_{m}z_{m-1}\dots z_1z_0)_{NAF}$}
        $xh\gets x >> 1$

        $x3\gets x + xh$

        $c\gets xh \text{ XOR } x3$

        $pb\gets x3 \text{ AND } c$

        $nb\gets xh \text{ AND } c$

        $z\gets pb - nb$
      \end{algorithm}
      Есть улучшенная версия данного представления:

      \begin{definition}
        Пусть $w\geqslant 2$ - положительное целое число. Тогда wNAF представление положительного числа $k$ - это представление $k=\sum_{i=0}^{l-1}k_i2^i$, где каждый ненулевой коэффициент $k_i$ нечётный, $|k_i|<2^{w-1}$, $k_{l-1}\neq 0$ и хотя бы одна ненулевая цифра есть в каждой подпоследовательности из $w$ цифр. Длина такого представления равна $l$. 
      \end{definition}
      \begin{theorem}[Свойства wNAF] Пусть $k$ - положительное целое число, тогда 
        \begin{enumerate}
          \item $k$ имеет уникальное представление wNAF, которое обозначается $NAF_w(k)$
          \item $NAF_2(k)=NAF(k)$, где $NAF(k)$ - это классическое бинарное представление в NAF 
          \item Длина $NAF_w(k)$ больше длины $(k)_2$ хотя бы на 1 цифру. 
          \item Средняя плотность ненулевых цифр в $wNAF$ представлении длины $l$ примерно $\frac{1}{w+1}$. 
        \end{enumerate}
      \end{theorem}
      Алгоритм вычисления $wNAF$ формы:

        \begin{algorithm}[H]
        \caption{Computing wNAF}
        \KwData{$w,k\in\N$}
          \KwResult{$NAF_w(k)$}
       $i\gets 0$

          \While{$k\geqslant 1$} {
            \eIf{$k$ is odd } {
              $k_i\gets k$ (mod $2^w$)
              $k\gets k - k_i$
            } {
              $k_i\gets 0$
            }
            $k_i\gets k/2$

            $i\gets i+1$
          }
          \Return $(k_{i-1},\dots,k_1,k_0)$
      \end{algorithm}
      \item Теперь напишем алгоритм вычисления кратной точки:

        \begin{algorithm}[H]
        \caption{wNAF for computing kP}
        \KwData{$w,k\in\N,P\in\E(\F_p)$}
          \KwResult{$Q:=kP$}
          $[k_i]\gets NAF_w(k)$

          Compute $P_i:=iP$ for $i\in \left\{1,3,5,\dots,2^{w-1}-1\right\}$

          $Q\gets \mathcal{O}$

          \For{$i$ from $l-1$ to 0} {
            $Q\gets 2Q$

            \If{$k_i\neq 0$} {
              \eIf{$k_i>0$} {
                $Q\gets Q + P_{k_i}$
              } {
                $Q\gets Q - P_{-{k_i}}$
              }
            }
          }
          \Return $Q$
      \end{algorithm}
      Также есть алгоритмы для вычисления кратной фиксированной точки. Они основаны на предварительных вычислениях и сохранении некоторой информации (т.е. кешировании данных).
    \end{enumerate}
    \subsubsection{Подсчёт точек на эллиптической кривой}

    Рассмотрим эллиптическую кривую $\E(\F_p)$, $p>3$.
    \begin{definition}
      Порядком точки $P\in \E(\F_p)$ называется такое наименьшее натуральное число $n$, что $nP=\mathcal{O}$ 
    \end{definition}
    \begin{definition}
      Эндоморфизмом Фробениуса $\Phi_p$ на эллиптической кривой называется:
      \[\Phi_p\colon \E(\overline{\F}_p)\to\E(\overline{\F}_p)\]
      \[(x,y)\mapsto (x^p,y^p)\]
      где $\overline{F}_p$ - это алгебраическое замыкание простого поля $\F_p$. 
    \end{definition}
    
    Эндоморфизм Фробениуса удовлетворяет следующему характеристическому уравнению:
    \begin{equation}\label{eq: char}
      \Phi_p^2 - t\Phi_p+p=0,\text{ где } t := p + 1 - \#\E(\F_p)
    \end{equation}
    Мы знаем, что значение $t$ ограниченно:
    \begin{theorem}[Хассе]
      \[\#\E(\F_p)=p+1-t,\q \text{ где }|t|\leqslant 2 \sqrt{p}\]
    \end{theorem}
    Из (\ref{eq: char}) мы получаем, что $\forall P:=(x,y)\in \E(\overline{F}_p)$ выполнено:
    \begin{equation}\label{eq: equation}
      (x^{p^2},y^{p^2}) +p(x,y)=t(x^p,y^p)
    \end{equation}
    где умножение на скаляры $p$ и $t$ означает сложение точки с собой $p$ или $t$ раз соответственно.
    \begin{definition}
      \[\E[l]:= \left\{P:=(x,y)\in\E(\overline{F}_p)\colon lP = \mathcal{O}\right\}\]
      Тогда каждая точка $P\in\E[l]$ называется точкой $l$-кручения. 
    \end{definition}

    Пусть $l$ - произвольное простое число, не равное $p$. Обозначим $\overline{t}:=t$ (mod $l$) и $\overline{p}:=p$ (mod $l$). Тогда, если $(x,y)\in \E[l]$, то из (\ref{eq: equation}) следует, что
    \[(x^{p^2},y^{p^2}) +\overline{p}(x,y)=\overline{t}(x^p,y^p)\]
    Значит, чтобы найти значение $t$, надо воспользоваться Китайской теоремой об остатках, но чтобы вычислить $t$ (mod $l$) для простых $l>2$, нужно сначала определить полиномы деления:

    \begin{definition}
      Полиномы деления - это последовательность полиномов $\Psi_m\in\Z[x,y,a,b]$, которая определена рекурсивно:
      \[\Psi_0 = 0\]
      \[\Psi_1 = 1\]
      \[\Psi_2 = 2y\]
      \[\Psi_3 = 3x^4+6ax^2+12bx-a^2\]
      \[\Psi_4 = 4y(x^6 + 5ax^4+20bx^3-5a^2x^2-4abx-8b^2-a^3)\]
      Тогда следующие полиномы определены как:
      \[\Psi_{2m+1} = \Psi_{m+2}\Psi_m^3 - \Psi_{m-1}\Psi_{m+1}^3,\q m\geqslant 2\]
      \[\Psi_{2m} = \left(\frac{\Psi_m}{2y}\right)\cdot (\Psi_{m+2}\Psi_{m-1}^2 - \Psi_{m-2}\Psi_{m+1}^2),\q m\geqslant 3\]
    \end{definition}

    Они обладают следующими свойствами:
    \begin{claim}
      Пусть эллиптическая кривая $\E(\F)$ задана уравнением $y^2 = x^3+ax+b$. Пусть $\Psi_m\in\Z[x,y]$ - полиномы деления, в которые подставили a и b из уравнения эллиптической кривой. Тогда корни $\Psi_{2n+1}$ - это точки из $\E[2n+1]\setminus \left\{\mathcal{O}\right\}$, а корни $\frac{\Psi_{2n}}{y}$ - это точки из $\E[2n]\setminus \E[2]$
    \end{claim}
    \begin{claim}
      Пусть $P:=(x,y)$ - точка на эллиптической кривой $\E(\overline{F}_p)$, заданной уравнением $y^2 = x^3+ax+b$. Пусть $n\in \Z$, тогда
      \[nP = \left(x - \frac{\Psi_{n-1}\Psi{n+1}}{\Psi_n^2}, \frac{\Psi_{n+2}\Psi_{n-1}^2-\Psi_{n-2}\Psi_{n+1}^2}{4y\Psi_n^3}\right)\]
    \end{claim}
    Эти ключевые утверждения позволяют имплементировать алгоритм Шуфа на практике. Теперь опишем сам алгоритм:

   \subsubsection{Алгоритм Шуфа}
    Дано: Эллиптическая кривая, заданная уравнением $y^2=x^3+ax+b$ над простым полем $\F_p$.

    Результат: Количество точек, т.е. $\#\E(\F_p)$
    \begin{enumerate}
      \item Создадим множество относительно маленьких простых чисел, которые не равны $p$:
      \[S:= \left\{l_1,l_2,\dots,l_L\right\} = \left\{2,3,5,7,11,\dots,l_L\right\}\]
      таких, что
      \[\prod_{i=1}^Ll_i > \lceil 4 \sqrt{p}\rceil\]
      \item Вычислим $t$ (mod $l$) для каждого $l$ из множества: 
      \begin{enumerate}
      \item Для $l=2$: Если $gcd(x^3+ax+b,x^p-x)\neq 1$, то $t\equiv 0$ (mod 2), иначе $t\equiv 1$ (mod 2). 
      \item Для $l\neq 2$: Пусть $p_l := p$ (mod l). Вычислим $x$-координату точки
      \[(x',y'):=(x^{p^2},y^{p^2})+p_l(x,y)\text{ mod } \Psi_l\]
      \item Для каждого $j=1,2,\dots,\frac{l-1}{2}$ сделаем следующее:
      \begin{enumerate}
        \item Вычислим $x$-координату точки $(x_j,y_j):=j(x,y)$.
        \item Если $x' - x^p-j\equiv 0\text{ mod } \Psi_l$, то переходим к следующему шагу. Иначе, пробуем следующее значение $j$.
        \item Вычисляем $y'$ и $y_j$. Если $\frac{y' - y_j^p}{y}\equiv 0\text{ mod } \Psi_l$, то $t\equiv j$ (mod $l$), иначе $t\equiv -j$ (mod $l$). 
      \end{enumerate}
      \item Если ни одно из значений не подошло, определим $w^2:=p_l$. Если не существует $w$, то $t\equiv 0$ (mod $l$).
      \item Если $gcd(numerator(x^p-x_w),\Psi_l)=1$, то $t\equiv 0$ (mod l). Иначе, вычислим:
      \[gcd(numerator(\frac{y^p-y_w}{y}),\Psi_l)\]
      \item Если вычисленный $gcd\neq 1$, то $t\equiv 2w$ (mod $l$), иначе $t\equiv -2w$ (mod $l$). 
      \end{enumerate}
      \item Восстанавливаем значение $t$ по Китайской теореме об остатках: пусть $T\equiv t$ (mod $N$), где $N:=\prod_{i=1}^Ll_i$.
      \item Если $T$ находится в границах теоремы Хассе, то $t = T$, иначе $t\equiv -T$ (mod $N$).
      \item Тогда $\#\E(\F_p) = p + 1 - t$
    \end{enumerate}
   
   Существует улучшенная версия алгоритма Шуфа, а именно алгоритм SEA, но оптимизации, представленные в нём достаточно сложно реализовать. Общая сложность алгоритма Шуфа - $O(\log^8p)$, алгоритма SEA - $O(\log^6p)$.
  \subsection{Алгоритмы Шифрования и цифровой подписи}
  \subsubsection{Алгоритм Эль-Гамаля}
  Общие данные: простое число $p$, эллиптическая кривая $\E(\F_p)$, точка на этой кривой $P\in\E(\F_p)$, её порядок $q$, отображение сообщения на эллиптическую кривую и обратное слева к нему отображение.

  Допустим Боб хочет отправить сообщение $m$ Алисе. Тогда:
  \begin{enumerate}
    \item Алиса генерирует секретный ключ $n_\alpha\colon 1\leqslant n_\alpha<q$, публичный ключ: $A:=n_\alpha P$. Отправляет публичный ключ Бобу.
    \item Боб обратимо отображает сообщение $m$ на эллиптическую кривую: $M\in\E(\F_p)$, генерирует одноразовый сектретный ключ $k\colon 1\leqslant k<q$, вычисляет $C_1:=kP,\q C_2:=kA+M$ и отправляет пару $(C_1,C_2)$ Алисе.
    \item Алиса вычисляет исходную точку по формуле:
    \[C_2 - n_\alpha C_1 =\]\[= kA+M - n_\alpha k P = n_\alpha k P + M - n_\alpha k P = M\]
    и отображает её обратно в $m$ 
  \end{enumerate}
  
  Отображать сообщение, представленное в виде двоичного числа, на эллиптическую кривую можно следующим образом:
  \begin{enumerate}
    \item Пусть наше поле $\F_p$, и $p$ - это достаточно большое число. Обозначим за $q$ - длину числа $p$ в битовом представлении.
    \item Выберем и зафиксируем число $l\in (0, \frac{q}{2})$, и будем в первые $l$ бит числа записывать наше сообщение $m$ в двоичном представлении.
    \item Заполним оставшиеся биты случайно. Тогда высока вероятность, что полученное число - это координата $x$ какой-то точки на эллиптической кривой. Если нет, то повторяем этот шаг, пока не получим точку на кривой.
    \item Когда Алиса посчитала точку $M$, она берёт координату $x$ этой точки. Тогда первые $l$ бит значения этой координаты и будут сообщением $m$. 
  \end{enumerate}

  Заметим, что отображать сообщения на кривую и обратно не является удобным. В вариации Эль-Гамаля с хешированием, выбирается хеш-функция $H\colon \E(\F_p)\to \left\{0,1\right\}^n$ и $(C_1,c_2) := (kP, m \oplus H(kA))$, т.е. сообщение в двоичном виде длины $\leqslant n$ XORится с хешем от точки $kA$. Тогда Алиса получает исходное сообщение через $m = c_2 \oplus H(n_\alpha C_1)$. 
  \subsubsection{ECDSA}
    У этого алгоритма есть несколько основных подалгоритмов:
    \begin{enumerate}
      \item Алгоритм генерации основных параметров: 

      Пользователь выбирает простое число $p$ и уровень безопасности $L\colon 160\leqslant L\leqslant [\log_2 p]$ и $2^L\geqslant 4 \sqrt{p}$. На выходе получаем основные параметры эллиптической кривой.

      \begin{enumerate}
        \item Выбираем верифицировано случайным образом $a,b\in \F_p\colon 4a^3+27b^2\neq 0$, чтобы они были параметрами эллиптической кривой. Назовём её $\E(\F_p)$
        \item Находим $N:=\#\E(\F_p)$
        \item Проверяем, что существует простое число $n\geqslant 2^L\colon N \equiv 0$ (mod $n$), т.е. что у $N$ в делителях есть большое простое число. Если это условие неверно, то переходим на первый шаг
        \item Проверяем, что для этого простого числа $p^k-1\not\equiv 0$ (mod $n$) $\forall k\in \left\{1,2,\dots,20\right\}$
        \item Проверим, что $p\neq n$, иначе переходим на шаг 1
        \item Пусть $h:=\frac{N}{n}$
        \item Генерируем случайную точку $G'\in \E(\F_p)$ и задаём $G:=hG'$. Если $G=\mathcal{O}$, то повторяем данный шаг.
        \item Возвращаем $D:=(p, a, b, F, E, G, n, h)$
      \end{enumerate}
      \item Алгоритм генерации ключей:

      Пользователь передаёт основные параметры $D$. На выходе получаем открытый и закрытый ключи.

      \begin{enumerate}
        \item Выбираем случайное число $d\in \left\{1,\dots,n-1\right\}$
        \item Вычисляем $Q:=dG$
        \item Возвращаем $(Q,d)$, где точка на эллиптической кривой $Q$ - открытый ключ, а $d\in\N$ - закрытый ключ
      \end{enumerate}

      \item Алгоритм генерации цифровой подписи:

      Пользователь, который имеет основные параметры $D$ и ключи $(Q,d)$, хочет подписать сообщение $m$. Пусть $H$ - криптографическая хеш-функция, результат которой даёт число, битовое представление которого имеет длину не более $n$. На выходе получаем подпись $(r,s)$:

      \begin{enumerate}
        \item Выбираем случайное число $k\in \left\{1,\dots,n-1\right\}$
        \item Вычисляем точку $(x_1,y_1)= kG$
        \item Вычисляем $r := x_1$ (mod $n$). Если $r=0$, то переходим к шагу 1
        \item Вычисляем $e := H(m)$
        \item Вычисляем $s := k^{-1}(e+dr)$ (mod $n$). Если $s=0$, то переходим к шагу 1
        \item Возвращаем $(r,s)$
      \end{enumerate}

      \item Алгоритм проверки цифровой подписи:

      Другой пользователь получает основные параметры $D$, хеш-функцию $H$, сообщение $m$, подпись $(r,s)$ и открытый ключ $Q$ от первого пользователя и хочет проверить подпись. На выходе получаем решение о принятии или отклонении подписи:

      \begin{enumerate}
        \item Если $r,s$ - это не целые числа, принадлежащие $[1,n-1]$, то отклоняем
        \item Вычисляем $e:=H(m)$
        \item Вычисляем $w := s^{-1} = k(e+dr)^{-1}$ (mod $n$) 
        \item Вычисляем $u_1:=ew$ (mod $n$) и $u_2:=rw$ (mod $n$)
        \item Вычисляем координаты точки $X=(x_1,y_1):=u_1G+u_2Q$
        \item Если $X=\mathcal{O}$, то отклоняем
        \item Вычисляем $v:=x_1$ (mod $n$)
        \item Если $v = r$, то принимаем, иначе отклоняем
      \end{enumerate}
    \end{enumerate}
\section{Архитектура проекта} 
\subsection{Доступные классы}
Верхними классами являются классы алгоритмов шифрования и подписи, которые строятся от эллиптической кривой. Эллиптическая кривая строится на простом поле, а простое поле зависит класса длинных чисел. Цепочка зависимостей:

\begin{center}
  \includegraphics[scale=0.7]{2.png}
\end{center}

Какие роли они выполняют - очевидно из названия.
\subsection{Расположение основных алгоритмов}
Перечислим, где используются алгоритмы, и их сложность:
\begin{enumerate}
  \item Класс uint\_t:
  \begin{itemize}
    \item Конструирование от строки длины $m$ за $O(m)$ 
    \item FFT - умножение длинных чисел за $O(n\log(n))$
    \item Algorithm D - деление длинных чисел за $O(n^2)$
    \item Конвертация к std::string длины $m$ за $O(m)$
    \item Все остальные методы беззнакового целого типа за $O(n)$
  \end{itemize}
  \item Класс FieldElement:
  \begin{itemize}
    \item Расширенный алгоритм Евклида для поиска обратного в поле за $O(n)$
    \item Быстрое возведение в степень $q$ за $O(\log(q))$
  \end{itemize}
  \item Класс EllipticCurve:
  \begin{itemize}
    \item Scoof's algorithm - Вычисление количества точек за $O(\log^8(n))$
    \item Нахождение $y$ координаты по $x$ за $O(\log(p))$ при $p\equiv 3$ (mod 4), и $O(\log^3(p))$ иначе. 
    \item Генерация случайной точки: генерация случайного uint и проверка наличия подходящей $y$ координаты
  \end{itemize}
  \item Класс EllipticCurvePoint:
  \begin{itemize}
    \item Сложение двух точек за $O(D + A)$, где $D$ и $A$ - деление и сложение в поле. 
  \end{itemize}
\end{enumerate}
Классы шифрования естественным образом реализуют шифрование.

\subsection{Дизайн решения}
Создан алиас uint для удобного тестирования при разных реализациях длинной арифметики.

\subsection{Взаимодействие}
Взаимодействие между классами заключается в использовании одними классами объектов и открытых методов другого, без закрытого общения между классами. Исключениями являются классы FieldElement и EllipticCurvePoint, у которых есть естественный доступ к Field и EllipticCurve соответственно.
\subsection{Тестирование}
Все основные классы покрыты тестами на корректность и стресс-тестами. В руководство добавлены диаграммы и таблицы результатов тестов на время и сравнение полученных скоростей с другими библиотеками, реализующими данный функционал. Протестирована разная компоновка и точечные оптимизации при некоторых предположениях о входных данных.
\newpage
\appendix
\section{Глоссарий}\label{glossary}
Термины и обозначения:
\begin{itemize}
  \item $p$ - простое число
  \item $q$ - положительное число, которое равно $p^n$, где $p$ - некоторое простое число, $n$ - некоторое натуральное число
  \item $(k)_2$ - беззнаковое представление целого числа $k$ в двоичной системе счисления.
  \item $\N$ - натуральные числа, начиная с 1
  \item $\Z$ - целые числа
  \item $\Z_n$ - кольцо вычетов по модулю $n$, использующее наименьшие неотрицательные вычеты
  \item $\Q$ - рациональные числа
  \item $\R$ - поле вещественных чисел 
  \item $\C$ - поле комплексных чисел
  \item $\F$ - произвольное поле
  \item $\F_p$ - поле простого порядка $p$, которое отождествляется $\Z_p$ 
  \item $\F_q$ - поле порядка $q=p^n$ 
  \item $\E(\F_q)$ - эллиптическая кривая над полем $\F_q$

  \item НОД или $gcd$ - наибольший общий делитель
  \item $f(x)$ - функция от $x$, $\R\to\R$ или $\C\to\C$ 
  \item $a_nx^n+a_{n-1}x^{n-1}+\dots+a_0$ - полином степени $n $от $x$ с коэффициентами $a_i\in\C$ или $\R$
  \item $P[x]$ - пространство полиномов от $x$, где $x\in\C$ или $\R$. 
  \item $R[a,b,c]$ - пространство полиномов от переменных a,b,c, где коэффициенты лежат в кольце R
  \item $P_n[x]$ - пространство полиномов степени $n$ от $x$
  \item Сложность алгоритма $O(f(n))$ - время работы алгоритма с увеличением параметра $n$, характеризующего количество входной информации алгоритма, будет возрастать не быстрее, чем $f(n)$, умноженная на некоторую константу

  \item $a\equiv b$ (mod $m$) - существует $k\in\Z\colon a - b = m\cdot k$. 
  \item $\overline{\F_p}$ - алгебраическое замыкание простого поля $\F_p$.
  \item $\#\E(\F_p)$ - количество точек на эллиптической кривой. 
  \item $numerator \left(\frac{P(x,y)}{Q(x,y)}\right):= P(x,y)$ - взятие числителя рациональной функции. 
\end{itemize}
\newpage
% Здесь автоматически генерируется библиография. Первая команда задает стиль оформления библиографии, а вторая указывает на имя файла с расширением bib, в котором находится информация об источниках.
\bibliographystyle{unsrt}
\addcontentsline{toc}{section}{Список литературы}
\bibliography{bibl}

% Здесь текст документа заканчивается
\end{document}
% Начиная с этого момента весь текст LaTeX игнорирует, можете вставлять любую абракадабру.
