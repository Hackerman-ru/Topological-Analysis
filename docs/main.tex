% Это основная команда, с которой начинается любой \LaTeX-файл. Она отвечает за тип документа, с которым связаны основные правил оформления текста.
\documentclass{article}

% Здесь идет преамбула документа, тут пишутся команды, которые настраивают LaTeX окружение, подключаете внешние пакеты, определяете свои команды и окружения. В данном случае я это делаю в отдельных файлах, а тут подключаю эти файлы.

% Здесь я подключаю разные стилевые пакеты. Например возможности набирать особые символы или возможность компилировать русский текст. Подробное описание внутри.
\usepackage{packages}

% Здесь я определяю разные окружения, например, теоремы, определения, замечания и так далее. У этих окружений разные стили оформления, кроме того, эти окружения могут быть нумерованными или нет. Все подробно объяснено внутри.
\usepackage{environments}

% Здесь я определяю разные команды, которых нет в LaTeX, но мне нужны, например, команда \tr для обозначения следа матрицы. Или я переопределяю LaTeX команды, которые работают не так, как мне хотелось бы. Типичный пример мнимая и вещественная часть комплексного числа \Im, \Re. В оригинале они выглядят не так, как мы привыкли. Кроме того, \Im еще используется и для обозначения образа линейного отображения. Подробнее описано внутри.
\usepackage{commands}

% Здесь я настроил пакет listings для отображения кода C++. Можно пользоваться непосредственно самим пакетом listings, но если вы про него ничего не знаете, то моя надстройка будет удобной стартовой точкой.
\usepackage{code}

% Потребуется для вставки картинки подписи
\usepackage{graphicx}

% Пакет для титульника проекта
\usepackage{titlepage}

% Здесь задаем параметры титульной страницы
\setUDK{192.168.1.1}
% Выбрать одно из двух
%\setToResearch
\setToProgram

\setTitle{ПО для топологического анализа данных}

% Выбрать одно из трех:
% КТ1 -- \setStageOne
% КТ2 -- \setStageTwo
% Финальная версия -- \setStageFinal
\setStageOne
%\setStageTwo
%\setStageFinal

\setGroup{225}
% Сюда можно воткнуть картинку подписи с помощью \includegraphics[scale=0.2]{<имя файла>}
% (scale подбирается индивидуально для конкретной картинки)
\setStudentSgn{\includegraphics[scale=0.2]{1.png}}
\setStudent{С.А.Корняков}
\setStudentDate{29.01.2025}
\setAdvisor{Качан Олег Николаевич}
\setAdvisorTitle{-}
\setAdvisorAffiliation{Лаборатория ИИ Сбербанка}
\setAdvisorDate{}
\setGrade{}
% Сюда можно воткнуть картинку подписи с помощью \includegraphics[scale=0.2]{<имя файла>}
% (scale подбирается индивидуально для конкретной картинки)
\setAdvisorSgn{}
\setYear{2025}


% С этого момента начинается текст документа
\begin{document}

% Эта команда создает титульную страницу
\makeTitlePage

% Здесь будет автоматически генерироваться содержание документа
\tableofcontents
\newpage
% Данное окружение оформляет аннотацию: краткое описание текста выделенным абзацем после заголовка
\begin{abstract}
  Цель работы заключается реализации библиотеки построения симплициальных комплексов из облаков точек (например, комплекса Вьеториса — Рипса), их фильтраций, вычисления диаграмм устойчивости с помощью новейших алгоритмов редуцирования матриц инцидентности (например, алгоритм DoubleTwist), а также вычисления собственных векторов матрицы Лапласиана, чтобы идентифицировать расположение дырок в пространстве. Библиотека будет поддерживать два режима: самый быстрый и модульный для экспериментов.

  \textit{Ключевые слова: топологический анализ, симплициальный комплекс, Вьеторис-Рипс, DoubleTwist, диаграмма устойчивости, параллельное вычисление, C++, оптимизация, Hodge Laplacian, persistent HH}
\end{abstract}
\section{Введение}


{\smallДля ознакомления с основными понятиями см. $\ref{glossary}$}

Современный объём информации, которая нуждается в анализе, обработке и сравнении друг с другом, ставит новые вызовы для учёных и исследователей в области топологического анализа. Уже давно изучен базовый математический аппарат и имплементированы библиотеки, которые могут строить симплициальные комплексы и вычислять их диаграммы устойчивости, но они постепенно устаревают. На замену им приходят новые теории и алгоритмы, которые могут на порядок превосходить прежние алгоритмы по скорости.

Задача проекта заключается в создании библиотеки, которая реализует и комбинирует алгоритмы, собранные с множества новейших статей, для ускоренного и параллельного вычисления симплициальных комплексов, диаграмм устойчивости и собственных векторов матрицы Лапласиана. Библиотека будет иметь два направления:
\begin{enumerate}
  \item Оптимизированная под конкретные алгоритмы для наибыстрейшего вычисления. Это позволит сравнить данную имплементацию с другими библиотеками на скорость
  \item Модульная, с максимальным количеством шаблонов и абстракций. Данная версия необходима в научных и исследовательских целях для экспериментов над гипотезами. Она позволит быстро и удобно реализовывать нужные для исследований алгоритмы и объекты почти наравне с языком программирования Python
\end{enumerate}

В поставленные задачи входит:
\subsection*{Изучение теории}
Изучить теорию, стоящую за симплициальными комплексами, гомологическими группами, диаграммами устойчивости и гармоническими пространствами. Исследовать алгоритмы построения комплексов, оптимальные для их хранения структуры данных, фильтрацию, построение матрицы инцидентности, её редуцирование с целью получения диаграмм устойчивости, построения матрицы Лапласиана и вычисления собственных векторов.
\subsection*{Реализация необходимых объектов}
Имплементировать на языке программирования C++ различные объекты для постройки нужного окружения для вычисления топологических объектов:
\begin{itemize}
  \item Симплекс
  \item Симплициальный комплекс, который хранится в виде дерева симплексов \cite{simplextree}
  \item Фильтрация симплициального комплекса
  \item Столбец и матрица индексов симлпексов в отфильтрованном симплициальном комплексе
  \item Стоблец индексов для быстрого сложения
    \begin{enumerate}
      \item В виде обычного вектора индексов
      \item В виде дерева битов \cite{bittreecolumn}
    \end{enumerate}
  \item Диаграмма устойчивости
  \item Матрица Лапласиана \cite{laplacianmatrix}
\end{itemize}

\subsection*{Имплементация алгоритмов}
Написать алгоритмы на полученных объектах:
\begin{itemize}
  \item Быстрое построение комплекса Вьеториса-Рипса над облаком точек \cite{fastvr}
  \item Редуцирование матрицы инцидентности фильтрованного симплициального комплекса:
  \begin{enumerate}
    \item Наивная реализация
    \item Параллельное редуцирование \cite{parallelreduce}
    \item Twist \cite{twist}
    \item DoubleTwist \cite{doubletwist}
  \end{enumerate}
  \item Вычисление матрицы Лапласиана
  \item Вычисление собственных векторов с собственным значением 0
\end{itemize}

\subsection*{Разделение написанного кода}
Разделить репозиторий на две ветки
\begin{enumerate}
  \item В одной максимально абстрагировать полученные классы с целью получения лучшей среды для экспериментов
  \item В другой рассмотреть разные комбинации алгоритмов и структур данных с целью выявить лучшую по скорости комбинацию и оптимизировать код под неё
\end{enumerate}

\subsection*{Тестирование библиотеки}
Провести стресс-тесты и тесты на корректность реализации алгоритмов. Измерить время работы для всех комбинаций алгоритмов и структур данных. Сделать выводы о лучшей компоновке. Для тестирования использовать готовое решение по тестированию проектов \cite{googletest}
\subsection*{Изложение результатов}
В отчёте изложить теорию, необходимую для понимания рассматриваемых алгоритмов и структур данных, а также описать архитектуру и дизайн библиотеки. Написать сопроводительную документацию для пользователей библиотеки.

\section{Требования к проекту}
\subsection{Функциональные требования}
Написанная библиотека на языке C++ должна предоставлять доступ к объектам, нужным для вычисления диаграмм устойчивости из облаков точек. Она должна обладать следующими объектами и методами:
\subsubsection{Генерация комплекса Вьеториса-Рипса по облаку точек}
Шаблонная функция, которая генерирует по массиву вершин и метрике комплекс Вьеториса-Рипса с заданными ограничениями по максимальному размеру симплексов и максимальной дистанции между вершинами в симплексе.
\subsubsection{Симплекс}
Шаблонный по типу вершины класс, содержащий вершины, которые принадлежат этому симплексу. Вершины должны быть упорядочены, то есть поддерживать \verb"std::partial_ordering operator<=>". Хранить их можно в векторе, сете или более хитрой структуре данных, например, в боре, где рёбра - номера вершин.

Класс симплексов должен предоставлять следующие публичные методы:
\begin{itemize}
  \item Построение от итераторов на структуру, содержащую вершины
  \item Получение размерности симплекса = "количество вершин - 1". Симплексы без вершин создавать нет смысла, поэтому определение корректно
  \item Получение подсимплексов - симплексов размерности на 1 меньше, которые содержатся в нём
  \item Получение набора вершин симплекса, чтобы функциям фильтрации было с чем работать
  \item Строковое представление симплекса при выводе через \verb"std::ostream& operator<<", чтобы можно было выводить результат. Естественно, будет поддерживать только если и сами вершины можно вывести тем же способом
\end{itemize}
\subsubsection{Симплициальный комплекс}
Шаблонный по типу вершины класс, который должен содержать в себе симплексы на заданных вершинах. Наиболее оптимальная и корректная по определению структура для их хранения - это дерево симплексов.

Класс комплексов должен предоставлять следующие публичные методы:
\begin{itemize}
  \item Построение от итераторов на структуру, содержащую симплексы
  \item Добавление произвольного числа симплексов
  \item Получение размера комплекса - количество содержащихся в нём симплексов
  \item Получение максимальной размерности симплексов в нём
  \item Получение набора симплексов в нём
  \item Строковое представление комплекса при выводе через \verb"std::ostream& operator<<", чтобы можно было выводить результат. Естественно, будет поддерживать только если и сами вершины можно вывести тем же способом
\end{itemize}
\subsubsection{Фильтрация симплициального комплекса}
Шаблонный по многим типам класс, который содержит в себе упорядоченное множество симплексов в комплексе, которые отсортированы по своим весам, которые определяются с помощью функции фильтрации, переданной в конструктор класса вместе с комплексом.

Класс фильтрации должен предоставлять следующие публичные методы:
\begin{itemize}
  \item Построение от комплекса и функции фильтрации
  \item Получение упорядоченного набора симплексов
  \item Получение индексера, который по симплексу выдаёт его номер в этом упорядоченном наборе
  \item Получение максимальной размерности симплексов в нём
\end{itemize}
\subsubsection{Столбцы и матрицы индексов}
Основные классы хранения индексов симплексов, где индексы - номер симплекса в фильтрации. Наивная реализация - вектор и вектор векторов из индексов.
\subsubsection{Столбцы для быстрого сложения}
Классы, содержащие в своей структуре данных индексы. Наивная реализация - обёртка над вектором индексов.

Они должны поддерживать:
\begin{itemize}
  \item Быстрое сложение с индексом и обычным столбцом из индексов, которые передаются в метод \verb"void add" с помощью итераторов
  \item Нахождение максимального индекса, который содержится в нём
  \item Конвертация в обычный столбец индексов. То есть чтобы можно было быстро очистить столбец от содержащихся индексов и загрузить следующий
\end{itemize}
\subsubsection{Диаграмма устойчивости}
Шаблонный по типу вершины класс, который содержит в себе существенные и несущественные пары устойчивости.

Класс должен поддерживать:
\begin{itemize}
  \item Добавление новой пары устойчивости по двум симплексам или одному, если это существенная пара
  \item Получение всех содержащихся пар
  \item Показ получившейся диаграммы с помощью вывода в \verb"stdout" всех пар
\end{itemize}
\subsubsection{Матрица Лапласиана}
Класс, который содержит матрицу Лапласиана для некоторого момента времени редуцирования комплекса.

Он должен поддерживать:
\begin{itemize}
  \item Создание из матрицы индексов и фильтрации симплициального комплекса
  \item Вычисление собственных векторов с собственным значением 0. Вектора имеют размерность количества вершин в комплексе.
\end{itemize}
\subsubsection{Алгоритмы редуцирования}
Шаблонные классы, которые строят матрицы инцидентности по фильтрации симплициального комлпекса и редуцируют её для получения диаграммы устойчивости. Планируется реализовать несколько вариантов, которые объявлены выше.
\subsubsection{Алгоритм поиска persistent HH}
Класс, который хранит в себе набор собственных векторов на текущий момент редуцирования, которые получает из матриц Лапласиана, и сравнивает их со следующим набором для поиска подходящего вектора, ответственного за создание некоторой дырки в комплексе.

По величинам значений элементов в этом векторе определяется расположение дырки в пространстве.
\cite{laplacianmatrix}
\subsection{Нефункциональные требования}
\subsubsection{Описание программы и используемых библиотек}
\begin{enumerate}
  \item Программа написана на языке C++, используется версия языка C++20
  \item Для сборки и тестирования кода используется кросс-платформенная система сборки CMake
  \item Программа поддерживает множество компиляторов, но основной - GCC
  \item Проект использует систему поддержки версий git вместе с github
  \item Требуется не менее 32GB RAM для корректной работы с большим объёмом данных
  \item Для форматирования используется clang format
  \item Используется clang-tidy для унификации именований и статической диагностики программы
\end{enumerate}
\subsubsection{Используемые библиотеки}
\begin{enumerate}
  \item Библиотека Boost.Asio для асинхронной и параллельной обработки матриц индексов \cite{boostasio}
  \item Фреймворк GTest для тестирования программы \cite{googletest}
\end{enumerate}
\subsubsection{Политика обработки ошибок}
\begin{enumerate}
  \item Обработка std::exception отключена в угоду оптимизации выполнения программы
  \item Вставлены assertы в DEBUG версии программы для выявления ошибок имплементации методов и алгоритмов
  \item Используется std::optional для обработки несуществования выходных данных алгоритмов и методов
\end{enumerate}
Подытоживая, программа предполагает, что использующий её пользователь вводит верные данные и следует ограничениям используемых алгоритмов.
\section{Теория и описание алгоритмов}
В разработке
\subsection{Дизайн решения}
В разработке
\subsection{Взаимодействие}
В разработке
\subsection{Тестирование}
В разработке
\newpage
\appendix
\section{Глоссарий}\label{glossary}
Термины и обозначения:
\begin{itemize}
  \item Вершины ($V$) - элементы линейно упорядоченного множества. В большинстве случаев это пронумерованные точки в пространстве $\R^3$
  \item Симплекс ($\sigma$) - фигура, объединяющая $n > 0$ вершин
  \item Размерность симплекса ($|\sigma|$) - количество вершин минус один
  \item k-симплекс ($\sigma_k$) - симплекс размерности k
  \item Подсимплекс ($\tau$) симплекса ($\sigma$) - фигура, состоящая из $n - 1$ вершины симплекса. Обозначение: $\tau\in\sigma$
  \item Комплекс ($K$) - набор симплексов, который содержит все подсимплексы своих симплексов:
    \[K\subset 2^V\colon \varnothing\in K;\q \forall \sigma \in K\q \forall \tau\in\sigma\implies \tau \in K\]
  % Большинство определений тут стоит перенести в основную часть
  %\item Функция фильтрации - функция, которая принимает на вход симплекс и возвращает его вес. Обычно вес $\in \R_+$
  %\item Фильтрованный симплициальный комплекс - упорядоченный по весу, размерности и номеру вершин набор симплексов из симплициального комплекса, полученный с помощью функции фильтрации
  %\item Матрица инцидентности - квадратная матрица, в которой и строки и столбцы привязаны симплексам фильтрованного симплициального комплекса. В самой матрице элементы из $\Z_2$. Если симплекс строки является подсимплексом симплекса столбца, то на месте их пересечения ставится 1, иначе ставится 0. 
\end{itemize}
\newpage
% Здесь автоматически генерируется библиография. Первая команда задает стиль оформления библиографии, а вторая указывает на имя файла с расширением bib, в котором находится информация об источниках.
\bibliographystyle{unsrt}
\addcontentsline{toc}{section}{Список литературы}
\bibliography{bibl}

% Здесь текст документа заканчивается
\end{document}
% Начиная с этого момента весь текст LaTeX игнорирует, можете вставлять любую абракадабру.

